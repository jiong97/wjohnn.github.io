<!DOCTYPE html>
<html lang>
  <head><meta name="generator" content="Hexo 3.9.0">
    
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,minimum-scale=1,maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="description" content="介绍了多路复用在网络和服务器中的作用，并且详细介绍了select、poll、epoll的作用和他们之间的区别">




  <meta name="keywords" content="网络,操作系统,Linux,">





  <link rel="alternate" href="/default" title="Jiong">






<link rel="canonical" href="http://wangjiong.me/2019/20190821.html">


<meta name="description" content="介绍了多路复用在网络和服务器中的作用，并且详细介绍了select、poll、epoll的作用和他们之间的区别">
<meta name="keywords" content="网络,操作系统,Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="I&#x2F;O多路复用: select, poll, epoll函数的介绍">
<meta property="og:url" content="http://wangjiong.me/2019/20190821.html">
<meta property="og:site_name" content="Jiong">
<meta property="og:description" content="介绍了多路复用在网络和服务器中的作用，并且详细介绍了select、poll、epoll的作用和他们之间的区别">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="http://wangjiong.me/img/multi/multiplexing.png">
<meta property="og:image" content="http://wangjiong.me/img/multi/tdm.png">
<meta property="og:updated_time" content="2019-09-24T05:22:51.063Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="I&#x2F;O多路复用: select, poll, epoll函数的介绍">
<meta name="twitter:description" content="介绍了多路复用在网络和服务器中的作用，并且详细介绍了select、poll、epoll的作用和他们之间的区别">
<meta name="twitter:image" content="http://wangjiong.me/img/multi/multiplexing.png">


<link rel="stylesheet" type="text/css" href="/css/style.css?v=1.1">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">





<script type="text/javascript">
  var themeConfig = {
    fancybox: {
      enable: false
    },
  };
</script>




  



    <title> I/O多路复用: select, poll, epoll函数的介绍 - Jiong </title>
  </head>

  <body>
    <div id="page">
      <header id="masthead"><div class="site-header-inner">
    <h1 class="site-title">
        <a href="/." class="logo">Jiong</a>
    </h1>

    <nav id="nav-top">
        
            <ul id="menu-top" class="nav-top-items">
                
                    <li class="menu-item">
                        <a href="/archives">
                            
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li class="menu-item">
                        <a href="/about">
                            
                            
                                About
                            
                        </a>
                    </li>
                
            </ul>
        
  </nav>
</div>

      </header>
      <div id="content">
        
    <div id="primary">
        
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          I/O多路复用: select, poll, epoll函数的介绍
        
      </h1>

      <time class="post-time">
          8月 21 2019
      </time>
    </header>



    
            <div class="post-content">
            <h2 id="什么是多路复用"><a href="#什么是多路复用" class="headerlink" title="什么是多路复用"></a>什么是多路复用</h2><p>多路复用(Multiplexing)原本是用在计算机网络和通讯之中的，它用来表示将多个模拟或数字信号结合在一起，通过一个共享信道进行传输，比如，多部电话可以共用一根电话线，下图形象地表达了这点。<br><img src="/img/multi/multiplexing.png" alt="发送端复用, 终端解复用" title="发送端复用, 终端解复用"></p>
<p>链路中最简单的时分多路复用（Time-division multiplexing，TDM），一些代理服务器（proxy）也用了TDM。TDM中的每个时间片被分为一个个帧（frame），帧又被分为时隙（slot），每个连接分得一个时隙，由该连接单独使用。<br><img src="/img/multi/tdm.png" alt="时分多路复用" title="时分多路复用"></p>
<h2 id="网络中的多路复用"><a href="#网络中的多路复用" class="headerlink" title="网络中的多路复用"></a>网络中的多路复用</h2><p>假设我们有以下场景，一个客户端同时处理两个socket，此时如果一个socket调用recv()接受数据。而另一个socket的服务器此时关闭，该服务器此时会发送一个<code>FIN</code>报文来通知该socket。但是客户端中有一个socket调用了recv，此时整个客户端都被OS阻塞（blocking），FIN信号将被丢失。解决这种问题的方式一般可通过给每个socket分配一个执行线程的方式解决。但这种解决方式将会增加实现复杂度，当线程数量躲起来后将会浪费更多时间在线程上线问切换上。</p>
<p>我们想要一种机制，当IO状态就绪时（read）得到通知的机制。这里的read并不是指IO完成，而是状态发生改变——input可读、socket可读入更多数据，这样我们就可以在一个线程中处理多个连接，这种能力就叫IO多路复用，他可以用在以下情景中：</p>
<ul>
<li>一个客端端持有多个fd（file discriptor，通常代表输入、管道或连接）</li>
<li>同时处理<code>listening socket</code>和<code>connected socket</code>的服务器</li>
</ul>
<h2 id="IO模型介绍"><a href="#IO模型介绍" class="headerlink" title="IO模型介绍"></a>IO模型介绍</h2><p>在Unix中，有5种可用到的模型，下面只介绍其中几种</p>
<ol>
<li>blocking I/O</li>
<li>nonblocking I/O</li>
<li>I/O multiplexing (select and poll)</li>
<li>signal driven I/O (SIGIO)</li>
<li>asynchronous I/O (the POSIX aio_ functions)</li>
</ol>
<p>在这里不过多阐述这几种IO的不同，可从其他文章获取。</p>
<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>一个fd代表一个连接，Unix会为每一个打开的文件分配一个非负整数。同一时刻服务器中可能有上千个连接，你需要知道连接中合适会发送数据，这样你才可以随时处理和相应它们。你可能需要一个基本的循环来处理他们。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for x in open_connections:</span><br><span class="line">    if has_new_input(x):</span><br><span class="line">        process_input(x)</span><br></pre></td></tr></table></figure>

<p>这种处理方法会浪费大量的CPU时间，因为他会轮询（polling）每一个连接。我们需要一种机制，当这些fd状态发生更新时，由操作系统通知我们。select就这样应运而生，它类似于：“hey，这里可以输入”。</p>
<p>select指示内核完成以下事情：</p>
<ul>
<li>等待我们向select中注册的一个或多个事件发生，然后唤醒线程</li>
<li>经过我们们指定的一段超时时间后唤醒</li>
</ul>
<p>select的用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> struct timeval *timeout)</span></span>;</span><br><span class="line"><span class="comment">/* Returns: positive count of ready descriptors, 0 on timeout, –1 on error */</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>maxfdp1</code>指定我们要注册给select的fd数量，这个参数只在Berkeley-like系统中起效</li>
<li><code>fd_set</code>是个fd的集合，当对应的事件发生时，如readable，它会被加如特定的set中，如<code>readset</code></li>
<li><code>timeout</code>指定超时时间</li>
</ul>
<p>timeval结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>  &#123;</span></span><br><span class="line">  <span class="keyword">long</span>   tv_sec;          <span class="comment">/* seconds */</span></span><br><span class="line">  <span class="keyword">long</span>   tv_usec;         <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>timeval参数指定的超时有如下几种情况：</p>
<ol>
<li>timeval为null，永久等待，直到一个或多个fd为IO完成准备</li>
<li>timeval不为空，等待一段固定的时间后唤醒，不管指定的超时时间内有无特定的事件发生，一定会唤醒</li>
<li>timeval为0，不唤醒，select直接返回。这种情况和轮询情况一样。</li>
</ol>
<p>select中的<code>fd_set</code>一般用整数数组来表示，实际上为<code>long</code>。过去一个fd_set通常只能包含32个fd，现在,UNIX系统通常会在头文件&lt;sys/select.h&gt;中定义常量<code>FD_SETSIZE</code>，它是数据类型fd_set的描述字数量，其值通常是1024，这样就能表示1024个的fd。fd_set中的每个bit表示对应的fd（fd就是一个数）。如果数组类型为<code>int</code>，则数组中的第一个元素表示第0-31个fd，第二个元素表示第32-63个fd。所有的实现细节都被隐藏在fd_set数据类型之中，对fd_set有如下几个操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *fdset)</span></span>;         <span class="comment">/* clear all bits in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">/* turn on the bit for fd in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">/* turn off the bit for fd in fdset */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; <span class="comment">/* is the bit for fd on in fdset ? */</span></span><br></pre></td></tr></table></figure>

<p>比如fd＝5,执行FD_SET(fd,&amp;set);后set变为0001,0000（第5位置为1）。FD_ZERO用于初始化一个fd_set指针。以下过程用于初始化一set，并注册fd 1、4、5。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fd_set rset;</span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;rset);          <span class="comment">/* initialize the set: all bits off */</span></span><br><span class="line">FD_SET(<span class="number">1</span>, &amp;rset);        <span class="comment">/* turn on bit for fd 1 */</span></span><br><span class="line">FD_SET(<span class="number">4</span>, &amp;rset);        <span class="comment">/* turn on bit for fd 4 */</span></span><br><span class="line">FD_SET(<span class="number">5</span>, &amp;rset);        <span class="comment">/* turn on bit for fd 5 */</span></span><br></pre></td></tr></table></figure>

<p>select中的readset，writeset，或exceptset，如果我们对其中某个时间不感兴趣，直接传递null即可。</p>
<p><code>maxfdp1</code>参数指示了将要被注册的fd的数量，这个参数之所以存在，是为了提升效率。一个进程的打开文件数是有限制的。一些Unix系统可以使这个数量不受限制。在不重新编译系统的情况下改变<code>FD_SETSIZE</code>通常是无效的。select会修改传入的readset, writeset, and exceptset，当select返回时，各个fd_set中的bit指示我们哪个fd发生了对应的事件，我们可以用FD_ISSET来测试我们感兴趣的事件是否发生。</p>
<p>一个socket达到可读状态，前提是下列条件之一为true：</p>
<ul>
<li><p>socket中都有一个接受低潮和发送低潮（low-water mark，LWM），接收缓冲区中的数据必须达到规定数量，内核才通知进程“可读”。比如触发select或者epoll，返回socket可读。接受LWM默认为1字节，发送LWM默认为2048字节。接受缓冲区的可读字节数大于等于LWM才可出发可读事件。可以通过设置<code>SO_RCVLOWAT</code>sokcet选项来设置LWM。</p>
</li>
<li><p>从远端服务器接受一个FIN报文，连接处于半关闭状态。</p>
</li>
</ul>
<h3 id="select的简要用法"><a href="#select的简要用法" class="headerlink" title="select的简要用法"></a>select的简要用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">int</span>         maxfdp1;</span><br><span class="line">fd_set      rset;</span><br><span class="line"><span class="keyword">char</span>        sendline[MAXLINE], recvline[MAXLINE];</span><br><span class="line"></span><br><span class="line">FD_ZERO(&amp;rset);</span><br><span class="line"><span class="keyword">for</span> ( ; ; ) &#123;</span><br><span class="line">    FD_SET(fileno(fp), &amp;rset);</span><br><span class="line">    FD_SET(sockfd, &amp;rset);</span><br><span class="line">    maxfdp1 = max(fileno(fp), sockfd) + <span class="number">1</span>;</span><br><span class="line">    Select(maxfdp1, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(sockfd, &amp;rset)) &#123;  <span class="comment">/* socket is readable */</span></span><br><span class="line">        <span class="comment">/* do something here */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FD_ISSET(fileno(fp), &amp;rset)) &#123;  <span class="comment">/* input is readable */</span></span><br><span class="line">        <span class="comment">/* do something here */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>poll提供的功能与select十分类似，poll为流设备（stream devices）提供了更多的信息。poll对较多数量的fd有性能优势，内核要检查fd_set中的每个bit。</p>
<p>大多数Unix都提供了poll系统调用。那些旧的系统会通过调用select来模拟poll。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *ufds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns: count of ready descriptors, 0 on timeout, –1 on error */</span></span><br></pre></td></tr></table></figure>

<p>pollfd的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span>     fd;       <span class="comment">/* descriptor to check */</span></span><br><span class="line">  <span class="keyword">short</span>   events;   <span class="comment">/* events of interest on fd */</span></span><br><span class="line">  <span class="keyword">short</span>   revents;  <span class="comment">/* events that occurred on fd */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ufds</code>是个<code>pollfd</code>数组，每个pollfd指定了将要被注册的fd，还有这个fd对应的事件。<code>events</code>是我们感兴趣的事件，<code>revents</code>是实际发生的事件，它们可以通过逻辑或（|）来组合事件。如果<code>timeout</code>是个负数，那么poll将会一直等待。部分参数如下表所示。</p>
<table>
<thead>
<tr>
<th>Constance</th>
<th>可注册?</th>
<th>可发生?</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>POLLIN</td>
<td>√</td>
<td>√</td>
<td>可读</td>
</tr>
<tr>
<td>POLLOUT</td>
<td>√</td>
<td>√</td>
<td>可写</td>
</tr>
<tr>
<td>POLLPRI</td>
<td>√</td>
<td>√</td>
<td>带外</td>
</tr>
<tr>
<td>POLLERR</td>
<td></td>
<td>√</td>
<td>异常</td>
</tr>
<tr>
<td>POLLHUP</td>
<td></td>
<td>√</td>
<td>挂起</td>
</tr>
<tr>
<td>POLLNVAL</td>
<td></td>
<td>√</td>
<td>指向异常</td>
</tr>
</tbody></table>
<h3 id="poll的简要用法"><a href="#poll的简要用法" class="headerlink" title="poll的简要用法"></a>poll的简要用法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/* For simplicity, all error checking has been left out */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfds</span>[2];</span></span><br><span class="line">    fd = open(argv[<span class="number">1</span>], O_RDONLY);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        pfds[<span class="number">0</span>].fd = <span class="number">0</span>;</span><br><span class="line">        pfds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">        </span><br><span class="line">        pfds[<span class="number">1</span>].fd = fd;</span><br><span class="line">        pfds[<span class="number">1</span>].events = POLLIN;</span><br><span class="line">        </span><br><span class="line">        poll(pfds, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (pfds[<span class="number">0</span>].revents &amp; POLLIN) &#123; <span class="comment">/* fd is readable */</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pfds[<span class="number">1</span>].revents &amp; POLLIN) &#123; <span class="comment">/* fd is readable */</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p>select和poll的调用，都要检查所有的fd是否ready，所以它的时间复杂度是O(n)，而epoll是O(1)。当有数十万连接中只有一个连接活跃时，select也要轮询FD_SET中所有的句柄。select与poll在内部机制方面并没有太大的差异。相比于select机制，poll只是取消了最大监控文件描述符数限制，并没有从根本上解决select存在的问题。</p>
<p>epoll是通过内核与用户空间mmap同一块内存实现的。mmap将用户空间的一块地址和内核空间的一块地址同时映射到相同的一块物理内存地址（不管是用户空间还是内核空间都是虚拟地址，最终要通过地址映射映射到物理地址），使得这块物理内存对内核和对用户均可见，减少用户态和内核态之间的数据交换。内核可以直接看到epoll监听的句柄，效率高。</p>
<p>epoll相关的调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* reates file descriptor of a new epoll instance */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Interest in particular file descriptors is then registered via epoll_ctl, </span></span><br><span class="line"><span class="comment">    add items to intere list */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* waits for I/O events, blocking the calling thread if no events are currently available */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>epoll_create</code>会返回一个代表epoll的fd，自Linux 2.6.8后，size被忽略，但需大于0，早期fd的组织时hash而不是红黑树，所以这个参数就失效了。epoll中含有有两个set，<code>interest list</code>和<code>ready list</code>。intere list中是我们注册的、受监视的fd，read list时为IO做好准备的fd集合。<code>epoll_ctl</code>用于向epoll中注册事件，<code>epoll_wait</code>则等待事件的发生，类似于select操作，epfd是epoll_create返回的fd，events是一个epoll_event*的指针，当epoll_wait这个函数操作成功之后，epoll_events里面将储存所有的读写事件，timeout表示超时事件，0表示立即返回，-1表示一直等待直到有事件发生。epoll_ctl中的<code>op</code>参数指定事件向epoll的interest list中添加、修改、移除的行为，event指定了事件，op可选值有以下几种：</p>
<ul>
<li>EPOLL_CTL_ADD 向epoll中添加一个fd</li>
<li>EPOLL_CTL_MOD 修改一个关联到fd的event</li>
<li>EPOLL_CTL_DEL 移除一个fd，event可以为null，它会被忽略</li>
</ul>
<p>event的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> events;      <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;        <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd;</span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<p>epoll_event中的events指定了该fd对什么事件感兴趣，它可以是以下几个宏的集合</p>
<ul>
<li>EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</li>
<li>EPOLLOUT：表示对应的文件描述符可以写</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</li>
<li>EPOLLERR：表示对应的文件描述符发生错误</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断</li>
<li>EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的</li>
<li>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</li>
</ul>
<p>事件可以进行如下组合：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ev.events = EPOLLIN | EPOLLPRI | EPOLLERR | EPOLLHUP;</span><br></pre></td></tr></table></figure>

<h3 id="level-trigger-与-edge-trigger"><a href="#level-trigger-与-edge-trigger" class="headerlink" title="level trigger 与 edge trigger"></a>level trigger 与 edge trigger</h3><p>边缘触发（ET）指每当状态发生改变时发生一个io事件，水平触发（LT）是只要满足条件就发生一个io事件。例如socket就收了100字节的数据，这时无论ET还是LT都会触发一个read事件，这时应用程序读取了50字节后调用epoll_wait，LT模式下会继续产生read而ET会因为没有事件变化而陷入等待。所以在使用ET时每次要注意读socket直到返回<code>EWOULDBLOCK</code>（非阻塞socket下，内核缓冲区为空）。</p>
<!-- ## 参考资料
- [Multiplexing](https://en.wikipedia.org/wiki/Multiplexing)

- [I/O Multiplexing: The select and poll Functions Introduction](https://notes.shichao.io/unp/ch6/)

- [Async IO on Linux: select, poll, and epoll](https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll/)

- [Multiplexed I/0 with poll()](https://www.linuxtoday.com/blog/multiplexed-i0-with-poll.html)

- [如果这篇文章说不清epoll的本质，那就过来掐死我吧！（3）](https://zhuanlan.zhihu.com/p/64746509) -->
            </div>
          

    
      <footer class="post-footer">
		
		<div class="post-tags">
		  
			<a href="/tags/网络/">网络</a>
		  
			<a href="/tags/操作系统/">操作系统</a>
		  
			<a href="/tags/Linux/">Linux</a>
		  
		</div>
		

        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2019/20190927.html">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">Redis持久化</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2019/20190807.html">
        <span class="next-text nav-default">数据库备份恢复及更新策略</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>

        
  <div class="comments" id="comments">
    
  </div>


      </footer>
    
  </article>

    </div>

      </div>

      <footer id="colophon"><span class="copyright-year">
    
        &copy;
    
    2019
    <span class="footer-author">Wang Jiong.</span>
    <span class="power-by">
        Powered by <a class="hexo-link" href="https://hexo.io/">Hexo</a>
    </span>
</span>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>
    


    




  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  

    <script type="text/javascript" src="/js/src/theme.js?v=1.1"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=1.1"></script>

  </body>
</html>
